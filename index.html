<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è”¬èœå¯¶å¯¶ï¼šå¹¾ä½•æ›è£åŸå‹</title>
    <style>
        /* --- CSS æ¨£å¼ (å„ªåŒ–æ‰‹æ©Ÿé¡¯ç¤º) --- */
        :root {
            --primary-color: #8BC34A; --secondary-color: #DCEDC8; --accent-color: #FF7043; --text-color: #333;
        }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'å¾®è»Ÿæ­£é»‘é«”', sans-serif; background-color: var(--secondary-color); touch-action: manipulation; }
        #game-container { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        #canvas-container { flex: 3; width: 100%; position: relative; background: linear-gradient(to bottom, #e0f7fa, #DCEDC8); }
        
        /* UI å±¤ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; padding: 15px; box-sizing: border-box; pointer-events: none; display: flex; justify-content: space-between; z-index: 20; }
        #affection-container { pointer-events: auto; background: rgba(255, 255, 255, 0.9); padding: 8px 15px; border-radius: 20px; display: flex; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #affection-label { margin-right: 10px; font-weight: bold; color: var(--primary-color); font-size: 0.9em; }
        #affection-bar-bg { width: 80px; height: 10px; background-color: #ddd; border-radius: 10px; overflow: hidden; }
        #affection-bar-fill { height: 100%; width: 0%; background-color: var(--accent-color); transition: width 0.5s; }
        #wardrobe-btn { pointer-events: auto; background: white; border: none; padding: 8px; border-radius: 50%; font-size: 22px; cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }

        /* æ›è£é¢æ¿ (æ”¹è‰¯ç‰ˆ) */
     /* æ›è£é¢æ¿ (æ”¹æˆè²¼å³å´ï¼Œä¸é®ä½ä¸­é–“è”¬èœå¯¶å¯¶) */
#wardrobe-panel {
    position: absolute;
    top: 50%;
    right: 10px;          /* è²¼å³é‚Š */
    left: auto;           /* ä¸å†ç”¨ left:50% */
    transform: translateY(-50%);   /* åªåœ¨ Y æ–¹å‘ç½®ä¸­ */

    background: rgba(255,255,255,0.95);
    padding: 20px;
    border-radius: 25px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    display: none;
    z-index: 100;
    text-align: center;

    width: 260px;         /* å›ºå®šå¯¬åº¦ï¼Œä¸å†ç”¨ 85% */
    max-width: 70%;
    max-height: 70%;
    overflow-y: auto;
}

        .wardrobe-title { color: var(--primary-color); margin-bottom: 15px; font-weight: bold; font-size: 1.2em;}
        .wardrobe-section-title { text-align: left; font-size: 0.9em; color: #666; margin: 10px 0 5px 5px; font-weight: bold;}
        .item-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 8px; margin-bottom: 10px; }
        .item-btn { border: 2px solid #eee; background: white; padding: 8px 5px; border-radius: 12px; cursor: pointer; font-size: 0.9em; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 60px; }
        .item-btn span { font-size: 1.5em; margin-bottom: 5px; }
        .item-btn.active { border-color: var(--accent-color); background-color: #FFF3E0; box-shadow: inset 0 0 5px rgba(255, 112, 67, 0.2);}
        #close-wardrobe { margin-top: 15px; background: var(--primary-color); color: white; border: none; padding: 10px 30px; border-radius: 25px; cursor: pointer; font-weight: bold; width: 100%; }

        /* æ€è€ƒèˆ‡å°è©±æ¡† */
        #thinking-bubble { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 8px 16px; border-radius: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-weight: bold; color: var(--primary-color); display: none; z-index: 10; font-size: 0.9em; white-space: nowrap; }
        #chat-container { flex: 2; background-color: #fff; display: flex; flex-direction: column; border-top-left-radius: 25px; border-top-right-radius: 25px; box-shadow: 0 -5px 20px rgba(0,0,0,0.1); overflow: hidden; z-index: 30; }
        #chat-history { flex: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; -webkit-overflow-scrolling: touch;}
        .message { max-width: 85%; padding: 10px 15px; border-radius: 18px; line-height: 1.4; font-size: 15px; position: relative; word-wrap: break-word;}
        .message.user { align-self: flex-end; background-color: var(--primary-color); color: white; border-bottom-right-radius: 5px; }
        .message.bot { align-self: flex-start; background-color: #f1f1f1; color: var(--text-color); border-bottom-left-radius: 5px; }
        .bot-name { font-size: 0.7em; color: #999; margin-bottom: 4px; position: absolute; top: -18px; left: 5px;}
        .message.bot { margin-top: 15px; } /* ç•™ç©ºé–“çµ¦åå­— */

        #input-area { display: flex; padding: 10px; background-color: #fafafa; border-top: 1px solid #eee; padding-bottom: calc(10px + env(safe-area-inset-bottom)); }
        #user-input { flex: 1; padding: 10px 15px; border: 2px solid #ddd; border-radius: 25px; outline: none; font-size: 16px; -webkit-appearance: none;}
        #user-input:focus { border-color: var(--primary-color); }
        #send-btn { margin-left: 8px; padding: 0 20px; border: none; border-radius: 25px; background-color: var(--primary-color); color: white; font-weight: bold; cursor: pointer; flex-shrink: 0;}
    </style>
</head>
<body>

    <div id="game-container">
        <div id="canvas-container"></div>

        <div id="ui-layer">
            <div id="affection-container">
                <span id="affection-label">å¥½æ„Ÿåº¦</span>
                <div id="affection-bar-bg"><div id="affection-bar-fill"></div></div>
            </div>
            <button id="wardrobe-btn">ğŸ’ æ›è£</button>
        </div>
        
        <div id="thinking-bubble">è®“æˆ‘æƒ³æƒ³... ğŸŒ±</div>

        <div id="wardrobe-panel">
            <div class="wardrobe-title">è”¬èœæ›´è¡£å®¤ (å¹¾ä½•ç‰ˆ)</div>
            <div id="wardrobe-content">
                </div>
            <button id="close-wardrobe">é—œé–‰</button>
        </div>

        <div id="chat-container">
            <div id="chat-history">
                <div class="message bot"><div class="bot-name">è”¬èœå¯¶å¯¶</div>å—¨ï¼æˆ‘æ˜¯ä½ çš„å¥½æœ‹å‹è”¬èœå¯¶å¯¶ æƒ³èŠå¤©çš„è©±éƒ½å¯ä»¥æ‰¾æˆ‘ã€‚é›–ç„¶ç¾åœ¨çœ‹èµ·ä¾†æœ‰é»æŠ½è±¡ï¼Œä½†ä½ å¯ä»¥å¹«æˆ‘æ›è£å–”ï¼ğŸ¥¦</div>
            </div>
            <div id="input-area">
                <input type="text" id="user-input" placeholder="è¼¸å…¥æ–‡å­—..." autocomplete="off">
                <button id="send-btn">ç™¼é€</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ==========================================
        // 1. éŠæˆ²æ ¸å¿ƒç‹€æ…‹
        // ==========================================
        let gameState = {
            affectionScore: 20, // åˆå§‹å¥½æ„Ÿåº¦
            equipped: {} // è¨˜éŒ„å·²è£å‚™çš„ç‰©å“ IDï¼Œä¾‹å¦‚ { 'hat_tophat': true }
        };
        const CANVAS_DEFAULT_BG = 'linear-gradient(to bottom, #e0f7fa, #DCEDC8)';

        // ==========================================
        // 2. é…ä»¶å®šç¾©ç³»çµ± (å¹¾ä½•åœ–å½¢ç‰ˆ)
        // ==========================================
        // é€™è£¡å®šç¾©æ¯å€‹é…ä»¶çš„åç¨±ã€éƒ¨ä½ï¼Œä»¥åŠå¦‚ä½•ç”¨ç¨‹å¼ç¢¼å‰µå»ºå®ƒ
        const accessoryDefinitions = {
            // --- é ­éƒ¨ (Head) ---
            'hat_tophat': { 
                name: 'ç´³å£«å¸½', icon: 'ğŸ©', type: 'head', 
                create: () => {
                    const group = new THREE.Group();
                    // å¸½ç­’ (åœ“æŸ±)
                    const top = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.6, 16), new THREE.MeshLambertMaterial({color: 0x3E2723}));
                    top.position.y = 1.25;
                    // å¸½æ²¿ (æ‰åœ“æŸ±)
                    const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.05, 16), new THREE.MeshLambertMaterial({color: 0x3E2723}));
                    brim.position.y = 0.95;
                    group.add(top, brim);
                    return group;
                }
            },
            'hat_egg': { 
                name: 'è·åŒ…è›‹', icon: 'ğŸ³', type: 'head', 
                create: () => {
                    const group = new THREE.Group();
                    // è›‹ç™½ (å£“æ‰çš„ç™½çƒ)
                    const white = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshLambertMaterial({color: 0xFFFFFF}));
                    white.scale.set(1, 0.2, 0.8);
                    white.position.y = 0.95;
                    // è›‹é»ƒ (å£“æ‰çš„é»ƒçƒ)
                    const yolk = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshLambertMaterial({color: 0xFFC107}));
                    yolk.scale.set(1, 0.6, 1);
                    yolk.position.set(0.1, 1.05, 0);
                    group.add(white, yolk);
                    return group;
                }
            },
            'hat_horns': { 
                name: 'æƒ¡é­”è§’', icon: 'ğŸ˜ˆ', type: 'head', 
                create: () => {
                    const group = new THREE.Group();
                    const hornMat = new THREE.MeshLambertMaterial({color: 0xD32F2F});
                    // å·¦è§’ (åœ“éŒ)
                    const left = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.4, 16), hornMat);
                    left.position.set(-0.4, 1.1, 0);
                    left.rotation.z = 0.3;
                    // å³è§’
                    const right = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.4, 16), hornMat);
                    right.position.set(0.4, 1.1, 0);
                    right.rotation.z = -0.3;
                    group.add(left, right);
                    return group;
                }
            },
            'hat_sprout': { 
                name: 'å°å«©èŠ½', icon: 'ğŸŒ±', type: 'head', 
                create: () => {
                    const group = new THREE.Group();
                    const mat = new THREE.MeshLambertMaterial({color: 0x8BC34A});
                    // è– (ç´°åœ“æŸ±)
                    const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8), mat);
                    stem.position.y = 1.1;
                    // è‘‰å­ (å…©å€‹å£“æ‰çš„çƒ)
                    const leaf1 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), mat);
                    leaf1.position.set(-0.1, 1.25, 0); leaf1.scale.set(1, 0.2, 0.5); leaf1.rotation.z = 0.5;
                    const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), mat);
                    leaf2.position.set(0.1, 1.25, 0); leaf2.scale.set(1, 0.2, 0.5); leaf2.rotation.z = -0.5;
                    group.add(stem, leaf1, leaf2);
                    return group;
                }
            },

            // --- è‡‰éƒ¨ (Face) ---
            'face_glasses': { 
                name: 'åœ“çœ¼é¡', icon: 'ğŸ‘“', type: 'face', 
                create: () => {
                    const group = new THREE.Group();
                    const glassMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
                    // é¡æ¡† (åœ“ç’°)
                    const glassGeo = new THREE.RingGeometry(0.15, 0.2, 16);
                    const gLeft = new THREE.Mesh(glassGeo, glassMat); gLeft.position.set(-0.35, 0.2, 0.92);
                    const gRight = new THREE.Mesh(glassGeo, glassMat); gRight.position.set(0.35, 0.2, 0.92);
                    // é¼»æ¨‘ (å°æ–¹å¡Š)
                    const bridge = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.05, 0.01), glassMat); bridge.position.set(0, 0.2, 0.92);
                    group.add(gLeft, gRight, bridge);
                    return group;
                }
            },
            'face_eyebrows': { 
                name: 'ç²—çœ‰æ¯›', icon: 'ğŸ¤¨', type: 'face', 
                create: () => {
                    const group = new THREE.Group();
                    const mat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                    // çœ‰æ¯› (å…©å€‹é•·æ–¹é«”)
                    const browGeo = new THREE.BoxGeometry(0.35, 0.08, 0.05);
                    const left = new THREE.Mesh(browGeo, mat); left.position.set(-0.35, 0.45, 0.85); left.rotation.z = 0.1;
                    const right = new THREE.Mesh(browGeo, mat); right.position.set(0.35, 0.45, 0.85); right.rotation.z = -0.1;
                    group.add(left, right);
                    return group;
                }
            },
            'face_blush_heart': {
                name: 'æ„›å¿ƒè…®ç´…', icon: 'ğŸ’–', type: 'face',
                create: () => {
                    // æ›¿æ›åŸæœ¬çš„åœ“å½¢è…®ç´…
                    const group = new THREE.Group();
                    // ç”¨å…©å€‹å°çƒæ‹¼ä¸€å€‹æ„›å¿ƒ (ç°¡åŒ–ç‰ˆ)
                    const heartMat = new THREE.MeshBasicMaterial({ color: 0xFF5252, transparent: true, opacity: 0.8 });
                    const makeHeart = (x) => {
                        const hG = new THREE.Group();
                        const s1 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), heartMat); s1.position.x = -0.07;
                        const s2 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), heartMat); s2.position.x = 0.07;
                        hG.add(s1, s2); hG.position.set(x, -0.1, 0.8); hG.scale.set(0.8, 0.8, 0.2);
                        return hG;
                    }
                    group.add(makeHeart(-0.6), makeHeart(0.6));
                    // éš±è—é è¨­è…®ç´…çš„é‚è¼¯éœ€è¦é¡å¤–è™•ç†ï¼Œé€™è£¡å…ˆç–ŠåŠ 
                    return group;
                }
            },

            // --- èº«é«” (Body) ---
            'body_scarf': { 
                name: 'ç´…åœå·¾', icon: 'ğŸ§£', type: 'body', 
                create: () => {
                    // åœå·¾ (ç”œç”œåœˆ/åœ“ç’°é«”)
                    const scarfGeo = new THREE.TorusGeometry(0.7, 0.2, 12, 32);
                    const scarfMat = new THREE.MeshLambertMaterial({ color: 0xE53935 });
                    const mesh = new THREE.Mesh(scarfGeo, scarfMat);
                    mesh.rotation.x = Math.PI / 2;
                    mesh.position.y = -0.55;
                    return mesh;
                }
            },
            'body_swimring': { 
                name: 'æ¸¸æ³³åœˆ', icon: 'ğŸ©', type: 'body', 
                create: () => {
                    // æ›´å¤§çš„ç”œç”œåœˆ
                    const geo = new THREE.TorusGeometry(0.9, 0.25, 16, 32);
                    const mat = new THREE.MeshLambertMaterial({ color: 0x03A9F4 }); // è—è‰²
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.rotation.x = Math.PI / 2;
                    mesh.position.y = -0.4;
                    return mesh;
                }
            },
            'body_bowtie': {
                name: 'é ˜çµ', icon: 'ğŸ€', type: 'body',
                create: () => {
                    const group = new THREE.Group();
                    const mat = new THREE.MeshLambertMaterial({ color: 0x9C27B0 }); // ç´«è‰²
                    // å…©å€‹éŒé«”æ‹¼æˆè´è¶çµ
                    const left = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.4, 16), mat);
                    left.rotation.z = Math.PI/2; left.position.x = -0.2;
                    const right = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.4, 16), mat);
                    right.rotation.z = -Math.PI/2; right.position.x = 0.2;
                    const center = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8,8), mat);
                    group.add(left, right, center);
                    group.position.set(0, -0.8, 0.6);
                    return group;
                }
            },

            // --- æ‰‹æŒ/æ¼‚æµ® (Floating) ---
            'float_balloon': { 
                name: 'ç´…æ°£çƒ', icon: 'ğŸˆ', type: 'floating', 
                create: () => {
                    const group = new THREE.Group();
                    // æ°£çƒæœ¬é«” (çƒ)
                    const balloon = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshLambertMaterial({color: 0xFF1744}));
                    balloon.position.set(1.2, 1.5, 0);
                    // ç¹©å­ (ç´°ç·š)
                    const stringGeo = new THREE.CylinderGeometry(0.01, 0.01, 1.5);
                    const stringMat = new THREE.MeshBasicMaterial({color: 0xcccccc});
                    const string = new THREE.Mesh(stringGeo, stringMat);
                    string.position.set(1.1, 0.7, 0);
                    string.rotation.z = -0.1;
                    group.add(balloon, string);
                    return group;
                }
            },
            'float_zzz': {
                name: 'ZZZç¬¦è™Ÿ', icon: 'ğŸ’¤', type: 'floating',
                create: () => {
                    const group = new THREE.Group();
                    // ç”¨ä¸‰å€‹å°æ–¹å¡Šæ¨¡æ“¬ Z (å¤ªè¤‡é›œäº†ï¼Œç”¨ç°¡å–®çƒé«”ä»£æ›¿ç¤ºæ„)
                    const zMat = new THREE.MeshBasicMaterial({color: 0x64B5F6});
                    const z1 = new THREE.Mesh(new THREE.SphereGeometry(0.1), zMat); z1.position.set(-1.2, 1.2, 0);
                    const z2 = new THREE.Mesh(new THREE.SphereGeometry(0.15), zMat); z2.position.set(-1.5, 1.5, 0);
                    const z3 = new THREE.Mesh(new THREE.SphereGeometry(0.2), zMat); z3.position.set(-1.8, 1.8, 0);
                    group.add(z1,z2,z3);
                    return group;
                }
            },
                    // --- èƒŒæ™¯ Background é¡ ---

        'bg_forest': {
            name: 'æ£®æ—è‰åœ°', icon: 'ğŸŒ³', type: 'background',
            bg: 'linear-gradient(to bottom, #C8E6C9, #A5D6A7)',
            create: () => {
                const group = new THREE.Group();

                // åœ“å½¢è‰åœ°
                const ground = new THREE.Mesh(
                    new THREE.CylinderGeometry(3.5, 3.5, 0.2, 32),
                    new THREE.MeshLambertMaterial({ color: 0xA5D6A7 })
                );
                ground.position.y = -1.2;
                group.add(ground);

                const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
                const leafMat = new THREE.MeshLambertMaterial({ color: 0x66BB6A });

                const makeTree = (x, z) => {
                    const t = new THREE.Group();
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.2, 1.3, 12),
                        trunkMat
                    );
                    trunk.position.y = -0.35;
                    const top = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 16, 16),
                        leafMat
                    );
                    top.position.y = 0.6;
                    t.add(trunk, top);
                    t.position.set(x, 0, z);
                    return t;
                };

                group.add(
                    makeTree(-2, -1.5),
                    makeTree(2, -1.8)
                );

                const bushGeo = new THREE.SphereGeometry(0.45, 12, 12);
                const bush1 = new THREE.Mesh(bushGeo, leafMat);
                bush1.position.set(-1.1, -0.8, 1.0);
                const bush2 = bush1.clone();
                bush2.position.set(1.2, -0.8, 0.6);
                group.add(bush1, bush2);

                return group;
            }
        },

        'bg_room': {
            name: 'æº«é¦¨æˆ¿é–“', icon: 'ğŸ ', type: 'background',
            bg: 'linear-gradient(to bottom, #FFE0B2, #FFF3E0)',
            create: () => {
                const group = new THREE.Group();

                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 4),
                    new THREE.MeshLambertMaterial({ color: 0xFFCC80 })
                );
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(0, -1, 1);
                group.add(floor);

                const wall = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 3),
                    new THREE.MeshLambertMaterial({ color: 0xFFE0B2 })
                );
                wall.position.set(0, 0, -2.5);
                group.add(wall);

                const desk = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.3, 1.0),
                    new THREE.MeshLambertMaterial({ color: 0xA1887F })
                );
                desk.position.set(-0.2, -0.6, 1.3);
                group.add(desk);

                const cushion = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 16, 16),
                    new THREE.MeshLambertMaterial({ color: 0xFFAB91 })
                );
                cushion.scale.set(1.4, 0.4, 1.4);
                cushion.position.set(1.6, -0.9, 1.2);
                group.add(cushion);

                return group;
            }
        },

        'bg_kitchen': {
            name: 'å°å°å»šæˆ¿', icon: 'ğŸ³', type: 'background',
            bg: 'linear-gradient(to bottom, #FFF3E0, #FFCCBC)',
            create: () => {
                const group = new THREE.Group();

                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 4),
                    new THREE.MeshLambertMaterial({ color: 0xFFE0B2 })
                );
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(0, -1, 1);
                group.add(floor);

                const wall = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 3),
                    new THREE.MeshLambertMaterial({ color: 0xFFCCBC })
                );
                wall.position.set(0, 0, -2.5);
                group.add(wall);

                // æµç†å°
                const counter = new THREE.Mesh(
                    new THREE.BoxGeometry(2.6, 0.8, 0.8),
                    new THREE.MeshLambertMaterial({ color: 0xFFAB91 })
                );
                counter.position.set(-1.5, -0.4, 1.4);
                group.add(counter);

                // ç°¡å–®é‹å­
                const pot = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.25, 16),
                    new THREE.MeshLambertMaterial({ color: 0x8D6E63 })
                );
                pot.position.set(-1.5, 0.1, 1.4);
                group.add(pot);

                // å†°ç®±
                const fridge = new THREE.Mesh(
                    new THREE.BoxGeometry(0.9, 1.8, 0.8),
                    new THREE.MeshLambertMaterial({ color: 0xE0F7FA })
                );
                fridge.position.set(2.0, -0.1, 1.4);
                group.add(fridge);

                return group;
            }
        },

        'bg_classroom': {
            name: 'æ•™å®¤é»‘æ¿', icon: 'ğŸ“š', type: 'background',
            bg: 'linear-gradient(to bottom, #BBDEFB, #E3F2FD)',
            create: () => {
                const group = new THREE.Group();

                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 4),
                    new THREE.MeshLambertMaterial({ color: 0xFFE0B2 })
                );
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(0, -1, 1);
                group.add(floor);

                const wall = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 3),
                    new THREE.MeshLambertMaterial({ color: 0x90CAF9 })
                );
                wall.position.set(0, 0, -2.5);
                group.add(wall);

                const board = new THREE.Mesh(
                    new THREE.PlaneGeometry(3.5, 1.6),
                    new THREE.MeshLambertMaterial({ color: 0x2E7D32 })
                );
                board.position.set(0, 0.3, -2.4);
                group.add(board);

                const desk = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.3, 1.0),
                    new THREE.MeshLambertMaterial({ color: 0xA1887F })
                );
                desk.position.set(0, -0.6, 1.3);
                group.add(desk);

                return group;
            }
        },

        'bg_stage': {
            name: 'èˆå°èšå…‰ç‡ˆ', icon: 'ğŸ¤', type: 'background',
            bg: 'radial-gradient(circle at top, #424242 0, #212121 55%, #000000 100%)',
            create: () => {
                const group = new THREE.Group();

                const floor = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 3, 0.3, 32),
                    new THREE.MeshLambertMaterial({ color: 0x4E342E })
                );
                floor.position.y = -1.1;
                group.add(floor);

                // èƒŒæ™¯å¹•
                const curtainMat = new THREE.MeshLambertMaterial({ color: 0xC62828 });
                const curtainL = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.8, 2.5),
                    curtainMat
                );
                curtainL.position.set(-2.3, 0, -2.2);
                curtainL.rotation.y = 0.2;

                const curtainR = curtainL.clone();
                curtainR.position.x = 2.3;
                curtainR.rotation.y = -0.2;

                group.add(curtainL, curtainR);

                // èšå…‰ç‡ˆç°¡å–®éŒå½¢
                const spotMat = new THREE.MeshBasicMaterial({ color: 0xFFF59D, transparent: true, opacity: 0.4 });
                const spot = new THREE.Mesh(
                    new THREE.ConeGeometry(2.2, 3.5, 16, 1, true),
                    spotMat
                );
                spot.position.set(0, 1.5, 0.2);
                spot.rotation.x = -Math.PI / 2.5;
                group.add(spot);

                return group;
            }
        },

        'bg_night': {
            name: 'å¤œæ™šæ˜Ÿç©º', icon: 'ğŸŒ™', type: 'background',
            bg: 'linear-gradient(to bottom, #283593, #1A237E)',
            create: () => {
                const group = new THREE.Group();

                const ground = new THREE.Mesh(
                    new THREE.CylinderGeometry(3.2, 3.2, 0.2, 32),
                    new THREE.MeshLambertMaterial({ color: 0x263238 })
                );
                ground.position.y = -1.2;
                group.add(ground);

                const moon = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0xFFF9C4 })
                );
                moon.position.set(2.0, 1.8, -2.5);
                group.add(moon);

                const starMat = new THREE.MeshBasicMaterial({ color: 0xFFF176 });
                const starGeo = new THREE.SphereGeometry(0.06, 8, 8);
                for (let i = 0; i < 20; i++) {
                    const s = new THREE.Mesh(starGeo, starMat);
                    s.position.set(
                        (Math.random() * 5) - 2.5,
                        0.5 + Math.random() * 2.0,
                        -2.4 - Math.random() * 0.4
                    );
                    group.add(s);
                }

                return group;
            }
        },

        'bg_rain': {
            name: 'é›¨å¤©çª—é‚Š', icon: 'ğŸŒ§ï¸', type: 'background',
            bg: 'linear-gradient(to bottom, #B3E5FC, #90CAF9)',
            create: () => {
                const group = new THREE.Group();

                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 4),
                    new THREE.MeshLambertMaterial({ color: 0xB0BEC5 })
                );
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(0, -1, 1);
                group.add(floor);

                const wall = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 3),
                    new THREE.MeshLambertMaterial({ color: 0xCFD8DC })
                );
                wall.position.set(0, 0, -2.5);
                group.add(wall);

                const windowFrame = new THREE.Mesh(
                    new THREE.PlaneGeometry(3.8, 2),
                    new THREE.MeshLambertMaterial({ color: 0x90CAF9 })
                );
                windowFrame.position.set(0, 0.3, -2.4);
                group.add(windowFrame);

                const dropMat = new THREE.MeshBasicMaterial({ color: 0xE3F2FD, transparent: true, opacity: 0.8 });
                const dropGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.7, 8);
                for (let i = 0; i < 8; i++) {
                    const d = new THREE.Mesh(dropGeo, dropMat);
                    d.position.set(-1.6 + i * 0.4, 0.6, -2.3);
                    group.add(d);
                }

                return group;
            }
        },

        'bg_snow': {
            name: 'é›ªåœ°ä¸–ç•Œ', icon: 'â„ï¸', type: 'background',
            bg: 'linear-gradient(to bottom, #E1F5FE, #FFFFFF)',
            create: () => {
                const group = new THREE.Group();

                const ground = new THREE.Mesh(
                    new THREE.CylinderGeometry(3.4, 3.4, 0.2, 32),
                    new THREE.MeshLambertMaterial({ color: 0xFFFFFF })
                );
                ground.position.y = -1.2;
                group.add(ground);

                const snowMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const body = new THREE.Mesh(
                    new THREE.SphereGeometry(0.6, 16, 16),
                    snowMat
                );
                body.position.set(-1.8, -0.4, -1.2);
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 16, 16),
                    snowMat
                );
                head.position.set(-1.8, 0.1, -1.2);
                group.add(body, head);

                const nose = new THREE.Mesh(
                    new THREE.ConeGeometry(0.08, 0.3, 8),
                    new THREE.MeshLambertMaterial({ color: 0xFF8A65 })
                );
                nose.position.set(-1.7, 0.05, -0.9);
                nose.rotation.x = Math.PI / 2;
                group.add(nose);

                const flakeMat = new THREE.MeshBasicMaterial({ color: 0xBBDEFB });
                const flakeGeo = new THREE.SphereGeometry(0.06, 8, 8);
                for (let i = 0; i < 18; i++) {
                    const f = new THREE.Mesh(flakeGeo, flakeMat);
                    f.position.set(
                        (Math.random() * 4) - 2,
                        0.5 + Math.random() * 2.0,
                        -1.5 + Math.random() * 2.5
                    );
                    group.add(f);
                }

                return group;
            }
        },

        'bg_beach': {
            name: 'æµ·é‚Šæ²™ç˜', icon: 'ğŸ–ï¸', type: 'background',
            bg: 'linear-gradient(to bottom, #80DEEA, #FFF9C4, #FFE082)',
            create: () => {
                const group = new THREE.Group();

                const sand = new THREE.Mesh(
                    new THREE.CylinderGeometry(3.6, 3.6, 0.2, 32),
                    new THREE.MeshLambertMaterial({ color: 0xFFE082 })
                );
                sand.position.y = -1.2;
                group.add(sand);

                const sea = new THREE.Mesh(
                    new THREE.CylinderGeometry(3.6, 3.6, 0.01, 32),
                    new THREE.MeshLambertMaterial({ color: 0x4FC3F7, transparent: true, opacity: 0.8 })
                );
                sea.position.set(0, -1.05, -1.0);
                group.add(sea);

                const umbrellaTop = new THREE.Mesh(
                    new THREE.ConeGeometry(0.9, 0.6, 16),
                    new THREE.MeshLambertMaterial({ color: 0xFF7043 })
                );
                umbrellaTop.position.set(2.0, 0.3, 0.3);
                const umbrellaPole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 1.4, 8),
                    new THREE.MeshLambertMaterial({ color: 0xB0BEC5 })
                );
                umbrellaPole.position.set(2.0, -0.4, 0.3);
                group.add(umbrellaTop, umbrellaPole);

                return group;
            }
        },

        'bg_dream': {
            name: 'ç²‰å½©å¤¢å¢ƒ', icon: 'ğŸ’­', type: 'background',
            bg: 'linear-gradient(to bottom, #E1BEE7, #BBDEFB)',
            create: () => {
                const group = new THREE.Group();

                const cloudMat = new THREE.MeshLambertMaterial({ color: 0xF3E5F5 });
                const makeCloud = (x, y, z) => {
                    const c = new THREE.Group();
                    const main = new THREE.Mesh(
                        new THREE.SphereGeometry(0.7, 16, 16),
                        cloudMat
                    );
                    const sub1 = new THREE.Mesh(
                        new THREE.SphereGeometry(0.5, 16, 16),
                        cloudMat
                    );
                    const sub2 = sub1.clone();
                    main.position.set(0, 0, 0);
                    sub1.position.set(-0.6, -0.1, 0.1);
                    sub2.position.set(0.6, -0.1, 0);
                    c.add(main, sub1, sub2);
                    c.position.set(x, y, z);
                    return c;
                };

                group.add(
                    makeCloud(-2.2, 1.4, -2.2),
                    makeCloud(2.0, 1.0, -2.0)
                );

                const bubbleMat = new THREE.MeshBasicMaterial({ color: 0xCE93D8, transparent: true, opacity: 0.6 });
                const bubbleGeo = new THREE.SphereGeometry(0.2, 16, 16);
                for (let i = 0; i < 8; i++) {
                    const b = new THREE.Mesh(bubbleGeo, bubbleMat);
                    b.position.set(
                        (Math.random() * 2.4) - 1.2,
                        0.4 + Math.random() * 1.6,
                        -1.0 + Math.random() * 1.5
                    );
                    group.add(b);
                }

                return group;
            }
        },

                    // --- æ–°å¢é…ä»¶ï¼šé ­é£¾ Head é¡ ---

        'hat_leafcrown': {
            name: 'è‘‰å­èŠ±å† ', icon: 'ğŸƒ', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0x8BC34A });
                const geo = new THREE.SphereGeometry(0.12, 8, 8);
                for (let i = 0; i < 7; i++) {
                    const leaf = new THREE.Mesh(geo, mat);
                    const angle = (i / 7) * Math.PI * 2;
                    leaf.position.set(Math.cos(angle) * 0.7, 0.95, Math.sin(angle) * 0.15);
                    leaf.scale.set(0.4, 1, 0.3);
                    leaf.rotation.z = angle;
                    group.add(leaf);
                }
                return group;
            }
        },

        'hat_flowercrown': {
            name: 'å°èŠ±èŠ±å† ', icon: 'ğŸŒ¸', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const colors = [0xF48FB1, 0xFFF59D, 0xCE93D8, 0xFFCC80];
                const geo = new THREE.SphereGeometry(0.14, 10, 10);
                for (let i = 0; i < 8; i++) {
                    const mat = new THREE.MeshLambertMaterial({ color: colors[i % colors.length] });
                    const flower = new THREE.Mesh(geo, mat);
                    const angle = (i / 8) * Math.PI * 2;
                    flower.position.set(Math.cos(angle) * 0.75, 1.0, Math.sin(angle) * 0.15);
                    group.add(flower);
                }
                return group;
            }
        },

        'hat_chef': {
            name: 'å»šå¸«å¸½', icon: 'ğŸ‘©â€ğŸ³', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const top = new THREE.Mesh(
                    new THREE.SphereGeometry(0.6, 16, 16),
                    whiteMat
                );
                top.scale.set(1.1, 0.8, 1.1);
                top.position.y = 1.4;
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.45, 0.45, 0.2, 16),
                    whiteMat
                );
                base.position.y = 1.05;
                group.add(top, base);
                return group;
            }
        },

        'hat_headphones': {
            name: 'å¤§è€³æ©Ÿ', icon: 'ğŸ§', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const earMat = new THREE.MeshLambertMaterial({ color: 0x424242 });
                const bandMat = new THREE.MeshLambertMaterial({ color: 0x616161 });

                const earGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 16);
                const left = new THREE.Mesh(earGeo, earMat);
                left.rotation.z = Math.PI / 2;
                left.position.set(-1.05, 0.4, 0);
                const right = left.clone();
                right.position.x = 1.05;

                const band = new THREE.Mesh(
                    new THREE.TorusGeometry(1.1, 0.06, 12, 32, Math.PI),
                    bandMat
                );
                band.rotation.z = Math.PI;
                band.position.y = 0.95;

                group.add(left, right, band);
                return group;
            }
        },

        'hat_raincap': {
            name: 'é›¨å¸½', icon: 'â˜”', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0x039BE5 });
                const dome = new THREE.Mesh(
                    new THREE.SphereGeometry(0.9, 20, 20, 0, Math.PI * 2, 0, Math.PI / 2),
                    mat
                );
                dome.position.y = 1.0;
                dome.scale.set(1.1, 0.7, 1.1);
                const brim = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.95, 0.95, 0.06, 20),
                    mat
                );
                brim.position.y = 0.85;
                group.add(dome, brim);
                return group;
            }
        },

        'hat_party': {
            name: 'æ´¾å°å¸½', icon: 'ğŸ‰', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const cone = new THREE.Mesh(
                    new THREE.ConeGeometry(0.45, 1.0, 16),
                    new THREE.MeshLambertMaterial({ color: 0xFFB74D })
                );
                cone.position.y = 1.3;
                const pom = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12, 10, 10),
                    new THREE.MeshLambertMaterial({ color: 0xFF4081 })
                );
                pom.position.y = 1.8;
                group.add(cone, pom);
                return group;
            }
        },

        'hat_crown': {
            name: 'é‡‘è‰²çš‡å† ', icon: 'ğŸ‘‘', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0xFFC107 });
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.55, 0.55, 0.18, 16),
                    mat
                );
                base.position.y = 1.0;
                for (let i = 0; i < 6; i++) {
                    const spike = new THREE.Mesh(
                        new THREE.ConeGeometry(0.15, 0.4, 8),
                        mat
                    );
                    const angle = (i / 6) * Math.PI * 2;
                    spike.position.set(Math.cos(angle) * 0.55, 1.3, Math.sin(angle) * 0.15);
                    group.add(spike);
                }
                group.add(base);
                return group;
            }
        },

        'hat_wizard': {
            name: 'å·«å¸«å¸½', icon: 'ğŸ§™â€â™‚ï¸', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0x5C6BC0 });
                const brim = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 0.8, 0.05, 20),
                    mat
                );
                brim.position.y = 0.95;
                const cone = new THREE.Mesh(
                    new THREE.ConeGeometry(0.6, 1.2, 20),
                    mat
                );
                cone.position.y = 1.4;
                cone.rotation.z = 0.15;
                group.add(brim, cone);
                return group;
            }
        },

        'hat_bunny': {
            name: 'å…”å…”è€³æœµ', icon: 'ğŸ°', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const outerMat = new THREE.MeshLambertMaterial({ color: 0xFFFDE7 });
                const innerMat = new THREE.MeshLambertMaterial({ color: 0xF8BBD0 });
                const earGeo = new THREE.BoxGeometry(0.25, 0.9, 0.15);

                const leftOuter = new THREE.Mesh(earGeo, outerMat);
                leftOuter.position.set(-0.35, 1.4, 0);
                const rightOuter = leftOuter.clone();
                rightOuter.position.x = 0.35;

                const innerGeo = new THREE.BoxGeometry(0.15, 0.7, 0.05);
                const leftInner = new THREE.Mesh(innerGeo, innerMat);
                leftInner.position.set(-0.35, 1.4, 0.08);
                const rightInner = leftInner.clone();
                rightInner.position.x = 0.35;

                group.add(leftOuter, rightOuter, leftInner, rightInner);
                return group;
            }
        },

        'hat_cat': {
            name: 'è²“è€³é«®ç®', icon: 'ğŸ±', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const band = new THREE.Mesh(
                    new THREE.TorusGeometry(0.85, 0.05, 12, 40, Math.PI),
                    new THREE.MeshLambertMaterial({ color: 0x424242 })
                );
                band.rotation.z = Math.PI;
                band.position.y = 0.9;

                const earMat = new THREE.MeshLambertMaterial({ color: 0xFFB74D });
                const earGeo = new THREE.ConeGeometry(0.25, 0.4, 8);
                const left = new THREE.Mesh(earGeo, earMat);
                left.position.set(-0.55, 1.1, 0);
                left.rotation.z = 0.3;
                const right = left.clone();
                right.position.x = 0.55;
                right.rotation.z = -0.3;

                group.add(band, left, right);
                return group;
            }
        },

        'hat_sleepcap': {
            name: 'ç¡å¸½', icon: 'ğŸ˜´', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0x90CAF9 });
                const cap = new THREE.Mesh(
                    new THREE.ConeGeometry(0.7, 1.4, 16),
                    mat
                );
                cap.position.set(0.2, 1.2, 0);
                cap.rotation.z = 0.6;
                const ball = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 10, 10),
                    new THREE.MeshLambertMaterial({ color: 0xE3F2FD })
                );
                ball.position.set(0.9, 0.9, 0);
                group.add(cap, ball);
                return group;
            }
        },

        'hat_antenna_star': {
            name: 'æ˜Ÿæ˜Ÿå¤©ç·š', icon: 'âœ¨', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const rodMat = new THREE.MeshLambertMaterial({ color: 0xB0BEC5 });
                const ballMat = new THREE.MeshLambertMaterial({ color: 0xFFF176 });
                const rodGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8);
                const ballGeo = new THREE.SphereGeometry(0.12, 10, 10);

                const leftRod = new THREE.Mesh(rodGeo, rodMat);
                leftRod.position.set(-0.4, 1.1, 0);
                const rightRod = leftRod.clone();
                rightRod.position.x = 0.4;

                const leftStar = new THREE.Mesh(ballGeo, ballMat);
                leftStar.position.set(-0.4, 1.35, 0);
                const rightStar = leftStar.clone();
                rightStar.position.x = 0.4;

                group.add(leftRod, rightRod, leftStar, rightStar);
                return group;
            }
        },

        'hat_goggles': {
            name: 'é ­æˆ´è­·ç›®é¡', icon: 'ğŸ¥½', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const frameMat = new THREE.MeshLambertMaterial({ color: 0x546E7A });
                const lensMat = new THREE.MeshBasicMaterial({ color: 0xB3E5FC, transparent: true, opacity: 0.6 });

                const frameGeo = new THREE.BoxGeometry(0.5, 0.25, 0.08);
                const leftFrame = new THREE.Mesh(frameGeo, frameMat);
                leftFrame.position.set(-0.4, 0.7, 0.8);
                const rightFrame = leftFrame.clone();
                rightFrame.position.x = 0.4;

                const lensGeo = new THREE.BoxGeometry(0.42, 0.18, 0.01);
                const leftLens = new THREE.Mesh(lensGeo, lensMat);
                leftLens.position.set(-0.4, 0.7, 0.85);
                const rightLens = leftLens.clone();
                rightLens.position.x = 0.4;

                const bridge = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.1, 0.05),
                    frameMat
                );
                bridge.position.set(0, 0.7, 0.8);

                group.add(leftFrame, rightFrame, leftLens, rightLens, bridge);
                return group;
            }
        },

        'hat_bandana': {
            name: 'é ­å·¾', icon: 'ğŸ§£', type: 'head',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0xFF7043 });
                const strip = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 0.25, 0.1),
                    mat
                );
                strip.position.set(0, 0.6, 0.6);
                const knot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 10, 10),
                    mat
                );
                knot.position.set(0.6, 0.6, 0.5);
                group.add(strip, knot);
                return group;
            }
        },

        // --- æ–°å¢é…ä»¶ï¼šè‡‰éƒ¨ Face é¡ ---

        'face_star_eyes': {
            name: 'æ˜Ÿæ˜Ÿçœ¼', icon: 'ğŸ¤©', type: 'face',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0xFFEB3B });
                const geo = new THREE.OctahedronGeometry(0.14, 0);
                const left = new THREE.Mesh(geo, mat);
                left.position.set(-0.4, 0.05, 0.95);
                const right = left.clone();
                right.position.x = 0.4;
                group.add(left, right);
                return group;
            }
        },
                // --- å˜´å·´ (Mouth) ---

        'mouth_smile': {
            name: 'å°å¾®ç¬‘å˜´', icon: 'ğŸ™‚', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const geo = new THREE.TorusGeometry(0.18, 0.035, 12, 24, Math.PI);
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const m = new THREE.Mesh(geo, mat);
                m.rotation.x = Math.PI / 2;
                m.position.set(0, -0.12, 0.9);
                group.add(m);

                // æŠŠæ•´çµ„å˜´å·´å¾€å‰æ¨ä¸€é»
                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_biggrin': {
            name: 'å¤§ç¬‘éœ²é½’', icon: 'ğŸ˜', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const lipGeo = new THREE.TorusGeometry(0.25, 0.04, 12, 24, Math.PI);
                const lipMat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const lip = new THREE.Mesh(lipGeo, lipMat);
                lip.rotation.x = Math.PI / 2;
                lip.position.set(0, -0.1, 0.9);

                const teeth = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.18, 0.02),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
                );
                teeth.position.set(0, -0.05, 0.91);

                group.add(lip, teeth);
                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_open': {
            name: 'Oå­—é©šè¨', icon: 'ğŸ˜®', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const geo = new THREE.TorusGeometry(0.16, 0.045, 10, 32);
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const m = new THREE.Mesh(geo, mat);
                m.rotation.x = Math.PI / 2;
                m.position.set(0, -0.05, 0.9);
                group.add(m);

                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_sad': {
            name: 'ä¸‹å¼§é›£é', icon: 'â˜¹ï¸', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const geo = new THREE.TorusGeometry(0.18, 0.035, 12, 24, Math.PI);
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const m = new THREE.Mesh(geo, mat);
                m.rotation.x = Math.PI / 2;
                m.rotation.z = Math.PI; // å€’éä¾†è®Šã€Œä¸‹å¼§ã€
                m.position.set(0, -0.18, 0.9);
                group.add(m);

                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_flat': {
            name: 'ç„¡è¨€ç›´ç·š', icon: 'ğŸ˜', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const geo = new THREE.BoxGeometry(0.35, 0.05, 0.03);
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const m = new THREE.Mesh(geo, mat);
                m.position.set(0, -0.1, 0.9);
                group.add(m);

                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_smirk': {
            name: 'æ–œå˜´å£ç¬‘', icon: 'ğŸ˜', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const geo = new THREE.BoxGeometry(0.3, 0.05, 0.03);
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const m = new THREE.Mesh(geo, mat);
                m.position.set(0.05, -0.1, 0.9);
                m.rotation.z = -0.25;
                group.add(m);

                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_cat': {
            name: 'è²“å’ªå˜´', icon: 'ğŸ±', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });

                const center = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.08, 0.03),
                    mat
                );
                center.position.set(0, -0.12, 0.9);

                const left = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.05, 0.03),
                    mat
                );
                left.position.set(-0.12, -0.15, 0.9);
                left.rotation.z = 0.3;

                const right = left.clone();
                right.position.x = 0.12;
                right.rotation.z = -0.3;

                group.add(center, left, right);
                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_wavy': {
            name: 'æŠ–æŠ–å˜´', icon: 'ğŸ˜–', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const geo = new THREE.BoxGeometry(0.14, 0.05, 0.03);
                const positions = [-0.18, 0, 0.18];
                positions.forEach((x, i) => {
                    const seg = new THREE.Mesh(geo, mat);
                    seg.position.set(x, -0.1 + ((i % 2) ? 0.04 : -0.04), 0.9);
                    group.add(seg);
                });

                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_tongue': {
            name: 'åèˆŒé ­', icon: 'ğŸ˜œ', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const lipGeo = new THREE.TorusGeometry(0.18, 0.035, 10, 24, Math.PI);
                const lipMat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const lip = new THREE.Mesh(lipGeo, lipMat);
                lip.rotation.x = Math.PI / 2;
                lip.position.set(0, -0.09, 0.9);

                const tongue = new THREE.Mesh(
                    new THREE.SphereGeometry(0.13, 12, 12),
                    new THREE.MeshBasicMaterial({ color: 0xF06292 })
                );
                tongue.scale.set(1, 0.7, 0.4);
                tongue.position.set(0, -0.18, 0.92);

                group.add(lip, tongue);
                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_three': {
            name: '3å­—å˜´', icon: 'ğŸ˜—', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const geo = new THREE.TorusGeometry(0.09, 0.03, 10, 20, Math.PI);

                const upper = new THREE.Mesh(geo, mat);
                upper.rotation.x = Math.PI / 2;
                upper.position.set(0, -0.06, 0.9);

                const lower = new THREE.Mesh(geo, mat);
                lower.rotation.x = Math.PI / 2;
                lower.rotation.z = Math.PI;
                lower.position.set(0, -0.14, 0.9);

                group.add(upper, lower);
                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_angry': {
            name: 'ç”Ÿæ°£å˜´', icon: 'ğŸ˜ ', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0x212121 });
                const geo = new THREE.BoxGeometry(0.3, 0.06, 0.03);
                const m = new THREE.Mesh(geo, mat);
                m.position.set(0, -0.14, 0.9);
                m.rotation.z = 0.12;
                group.add(m);

                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        'mouth_zip': {
            name: 'å°å˜´æ‹‰éŠ', icon: 'ğŸ¤', type: 'mouth',
            create: () => {
                const group = new THREE.Group();
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.06, 0.03),
                    new THREE.MeshBasicMaterial({ color: 0x212121 })
                );
                base.position.set(0, -0.1, 0.9);

                const teeth = new THREE.Mesh(
                    new THREE.BoxGeometry(0.32, 0.03, 0.01),
                    new THREE.MeshBasicMaterial({ color: 0xB0BEC5 })
                );
                teeth.position.set(0, -0.1, 0.92);

                group.add(base, teeth);
                group.position.set(0, 0, 0.15);
                return group;
            }
        },

        // --- æ–°å¢é…ä»¶ï¼šèº«é«” Body é¡ ---

        'body_apron': {
            name: 'å°åœè£™', icon: 'ğŸ³', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0xFFE0B2 });
                const apron = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 1.0, 0.05),
                    mat
                );
                apron.position.set(0, -0.5, 0.8);
                const pocket = new THREE.Mesh(
                    new THREE.BoxGeometry(0.45, 0.3, 0.02),
                    new THREE.MeshLambertMaterial({ color: 0xFFCC80 })
                );
                pocket.position.set(0, -0.7, 0.83);
                group.add(apron, pocket);
                return group;
            }
        },

       

        'body_cape': {
            name: 'è¶…äººæŠ«é¢¨', icon: 'ğŸ¦¸', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0xF44336, side: THREE.DoubleSide });
                const cape = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.2, 2.6, 1, 2),
                    mat
                );
                cape.position.set(0, -0.2, -0.95);
                cape.rotation.x = Math.PI * 0.1;
                group.add(cape);
                return group;
            }
        },

        'body_raincoat': {
            name: 'é›¨è¡£æ–—ç¯·', icon: 'ğŸŒ§ï¸', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0x4FC3F7, transparent: true, opacity: 0.9 });
                const coat = new THREE.Mesh(
                    new THREE.SphereGeometry(1.25, 24, 24, 0, Math.PI * 2, Math.PI / 3, Math.PI / 2),
                    mat
                );
                coat.scale.set(1, 1.1, 1);
                coat.position.y = -0.2;
                group.add(coat);
                return group;
            }
        },

        'body_shield': {
            name: 'å°ç›¾ç‰Œ', icon: 'ğŸ›¡ï¸', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0x90A4AE });
                const shield = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.45, 0.45, 0.06, 16),
                    mat
                );
                shield.rotation.x = Math.PI / 2;
                shield.position.set(0.9, -0.3, 0.4);
                const emblem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.25, 0.08, 12),
                    new THREE.MeshLambertMaterial({ color: 0xFFCA28 })
                );
                emblem.rotation.x = Math.PI / 2;
                emblem.position.copy(shield.position);
                emblem.position.z += 0.05;
                group.add(shield, emblem);
                return group;
            }
        },

        'body_towel': {
            name: 'æµ´å·¾', icon: 'ğŸ›', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0xFFF59D });
                const towel = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 0.6, 0.1),
                    mat
                );
                towel.position.set(0, -0.1, 0.7);
                group.add(towel);
                return group;
            }
        },

        'body_belt': {
            name: 'çš®å¸¶', icon: 'ğŸŒ€', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const belt = new THREE.Mesh(
                    new THREE.TorusGeometry(0.9, 0.08, 10, 32),
                    new THREE.MeshLambertMaterial({ color: 0x5D4037 })
                );
                belt.rotation.x = Math.PI / 2;
                belt.position.y = -0.5;

                const buckle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.25, 0.05),
                    new THREE.MeshLambertMaterial({ color: 0xFFEE58 })
                );
                buckle.position.set(0, -0.5, 0.9);
                group.add(belt, buckle);
                return group;
            }
        },

        'body_leafskirt': {
            name: 'è‘‰å­è£™', icon: 'ğŸ€', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0x66BB6A });
                const geo = new THREE.SphereGeometry(0.3, 10, 10);
                for (let i = 0; i < 8; i++) {
                    const leaf = new THREE.Mesh(geo, mat);
                    const angle = (i / 8) * Math.PI * 2;
                    leaf.position.set(Math.cos(angle) * 1.0, -0.85, Math.sin(angle) * 0.6);
                    leaf.scale.set(0.4, 1.1, 0.3);
                    leaf.rotation.z = angle;
                    group.add(leaf);
                }
                return group;
            }
        },

        'body_necklace': {
            name: 'ç ç é …éŠ', icon: 'ğŸ“¿', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const colors = [0xFF7043, 0xFFCA28, 0xAB47BC, 0x29B6F6];
                const geo = new THREE.SphereGeometry(0.12, 10, 10);
                for (let i = 0; i < 9; i++) {
                    const mat = new THREE.MeshLambertMaterial({ color: colors[i % colors.length] });
                    const bead = new THREE.Mesh(geo, mat);
                    const angle = (i / 9) * Math.PI;
                    bead.position.set(Math.cos(angle) * 0.8, -0.35 + Math.sin(angle) * 0.1, 0.75);
                    group.add(bead);
                }
                return group;
            }
        },

        'body_sweater': {
            name: 'æ¯›è¡£ç´‹è·¯', icon: 'ğŸ§¶', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0xFFCC80, transparent: true, opacity: 0.8 });
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.95, 0.12, 12, 32),
                    mat
                );
                ring.rotation.x = Math.PI / 2;
                ring.position.y = -0.3;
                group.add(ring);
                return group;
            }
        },

        'body_shellarmor': {
            name: 'è²æ®¼èƒ¸ç”²', icon: 'ğŸš', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0xFFE0B2 });
                const geo = new THREE.SphereGeometry(0.4, 14, 14);
                const left = new THREE.Mesh(geo, mat);
                left.scale.set(1, 0.6, 0.4);
                left.position.set(-0.4, -0.35, 0.85);
                const right = left.clone();
                right.position.x = 0.4;
                group.add(left, right);
                return group;
            }
        },

       
        'body_wings': {
            name: 'å°ç¿…è†€', icon: 'ğŸª½', type: 'body',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0xE3F2FD, side: THREE.DoubleSide });
                const geo = new THREE.PlaneGeometry(0.9, 1.3);
                const left = new THREE.Mesh(geo, mat);
                left.position.set(-1.1, -0.2, 0);
                left.rotation.y = Math.PI / 2.4;
                const right = left.clone();
                right.position.x = 1.1;
                right.rotation.y = -left.rotation.y;
                group.add(left, right);
                return group;
            }
        },

        // --- æ–°å¢é…ä»¶ï¼šæ¼‚æµ® Floating é¡ ---

        'float_music': {
            name: 'éŸ³ç¬¦é£„é£„', icon: 'ğŸµ', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0x7E57C2 });
                const geo = new THREE.SphereGeometry(0.15, 10, 10);
                const note1 = new THREE.Mesh(geo, mat);
                note1.position.set(1.4, 0.8, 0);
                const note2 = new THREE.Mesh(geo, mat);
                note2.position.set(1.0, 1.3, 0.1);
                const barGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 8);
                const bar = new THREE.Mesh(barGeo, mat);
                bar.position.set(1.2, 1.05, 0.05);
                bar.rotation.z = -0.6;
                group.add(note1, note2, bar);
                return group;
            }
        },

        'float_bubbles': {
            name: 'æ³¡æ³¡', icon: 'ğŸ«§', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0xB3E5FC, transparent: true, opacity: 0.6 });
                [ [1.3, 0.6], [1.8, 1.2], [1.1, 1.4] ].forEach(([x, y], i) => {
                    const bubble = new THREE.Mesh(
                        new THREE.SphereGeometry(0.18 + i * 0.05, 12, 12),
                        mat
                    );
                    bubble.position.set(x, y, 0);
                    group.add(bubble);
                });
                return group;
            }
        },

        'float_stars': {
            name: 'å°æ˜Ÿæ˜Ÿç¾¤', icon: 'ğŸŒŸ', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0xFFF59D });
                const geo = new THREE.OctahedronGeometry(0.18, 0);
                const positions = [
                    [-1.4, 1.1, 0],
                    [-1.8, 1.5, 0.1],
                    [-1.1, 1.7, -0.1]
                ];
                positions.forEach(p => {
                    const star = new THREE.Mesh(geo, mat);
                    star.position.set(p[0], p[1], p[2]);
                    group.add(star);
                });
                return group;
            }
        },

        'float_leaves': {
            name: 'é£„è½è‘‰ç‰‡', icon: 'ğŸƒ', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: 0x81C784 });
                const geo = new THREE.SphereGeometry(0.18, 10, 10);
                const positions = [
                    [-1.6, 0.9, 0],
                    [-1.9, 0.5, 0.1],
                    [-1.3, 0.4, -0.1]
                ];
                positions.forEach((p, i) => {
                    const leaf = new THREE.Mesh(geo, mat);
                    leaf.position.set(p[0], p[1], p[2]);
                    leaf.scale.set(0.5, 1.2, 0.3);
                    leaf.rotation.z = -0.5 + i * 0.4;
                    group.add(leaf);
                });
                return group;
            }
        },

        'float_fireflies': {
            name: 'è¢ç«èŸ²å…‰é»', icon: 'âœ¨', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0xFFEB3B });
                const geo = new THREE.SphereGeometry(0.06, 8, 8);
                for (let i = 0; i < 7; i++) {
                    const dot = new THREE.Mesh(geo, mat);
                    dot.position.set(
                        (Math.random() * 1.5) - 0.75,
                        1.0 + Math.random() * 0.8,
                        -0.4 + Math.random() * 0.8
                    );
                    group.add(dot);
                }
                return group;
            }
        },

        'float_raincloud': {
            name: 'å°é›¨é›²', icon: 'ğŸŒ§ï¸', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const cloudMat = new THREE.MeshLambertMaterial({ color: 0xCFD8DC });
                const geo = new THREE.SphereGeometry(0.35, 12, 12);
                const c1 = new THREE.Mesh(geo, cloudMat);
                c1.position.set(0, 1.7, 0);
                const c2 = c1.clone(); c2.position.x = 0.4;
                const c3 = c1.clone(); c3.position.x = -0.4;
                group.add(c1, c2, c3);
                const dropMat = new THREE.MeshBasicMaterial({ color: 0x81D4FA });
                const dropGeo = new THREE.SphereGeometry(0.08, 8, 8);
                for (let i = 0; i < 4; i++) {
                    const d = new THREE.Mesh(dropGeo, dropMat);
                    d.scale.set(0.7, 1.3, 0.7);
                    d.position.set(-0.3 + i * 0.2, 1.3 - Math.random() * 0.1, 0);
                    group.add(d);
                }
                return group;
            }
        },

        'float_sun': {
            name: 'å°å¤ªé™½', icon: 'â˜€ï¸', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const core = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 14, 14),
                    new THREE.MeshBasicMaterial({ color: 0xFFEE58 })
                );
                core.position.set(1.7, 1.6, -0.2);
                group.add(core);
                return group;
            }
        },

        'float_moon': {
            name: 'æ–°æœˆ', icon: 'ğŸŒ™', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0xFFF9C4 });
                const big = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 12, 12),
                    mat
                );
                const cut = new THREE.Mesh(
                    new THREE.SphereGeometry(0.32, 12, 12),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                big.position.set(-1.7, 1.6, 0);
                cut.position.set(-1.6, 1.6, 0.05);
                group.add(big, cut);
                return group;
            }
        },

        'float_hearts': {
            name: 'æ„›å¿ƒæ³¡æ³¡', icon: 'ğŸ’—', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0xFF80AB, transparent: true, opacity: 0.9 });
                const geo = new THREE.SphereGeometry(0.16, 10, 10);
                const positions = [
                    [1.4, 1.0, 0],
                    [1.7, 1.3, 0.1],
                    [1.2, 1.5, -0.1]
                ];
                positions.forEach(p => {
                    const h = new THREE.Mesh(geo, mat);
                    h.scale.set(1.1, 0.8, 0.4);
                    h.position.set(p[0], p[1], p[2]);
                    group.add(h);
                });
                return group;
            }
        },

        'float_carrot': {
            name: 'èƒ¡è˜¿è””æƒ³åƒåœ–', icon: 'ğŸ¥•', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const body = new THREE.Mesh(
                    new THREE.ConeGeometry(0.25, 0.8, 12),
                    new THREE.MeshLambertMaterial({ color: 0xFF9800 })
                );
                body.position.set(-1.5, 1.1, 0.1);
                body.rotation.z = -0.4;
                const leafMat = new THREE.MeshLambertMaterial({ color: 0x81C784 });
                const leaf = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 10, 10),
                    leafMat
                );
                leaf.scale.set(0.5, 1, 0.5);
                leaf.position.set(-1.2, 1.4, 0.1);
                group.add(body, leaf);
                return group;
            }
        },

        'float_veggies': {
            name: 'è”¬èœç’°ç¹', icon: 'ğŸ¥¦', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const colors = [0x81C784, 0xFFB74D, 0xCE93D8];
                const geo = new THREE.SphereGeometry(0.2, 10, 10);
                const positions = [
                    [-1.8, 0.9, 0],
                    [-1.3, 1.2, 0.2],
                    [-1.6, 1.5, -0.2]
                ];
                positions.forEach((p, i) => {
                    const veg = new THREE.Mesh(
                        geo,
                        new THREE.MeshLambertMaterial({ color: colors[i] })
                    );
                    veg.scale.set(0.8, 1.1, 0.7);
                    veg.position.set(p[0], p[1], p[2]);
                    group.add(veg);
                });
                return group;
            }
        },

        'float_book': {
            name: 'å°æ›¸æœ¬', icon: 'ğŸ“–', type: 'floating',
            create: () => {
                const group = new THREE.Group();
                const coverMat = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
                const pageMat = new THREE.MeshLambertMaterial({ color: 0xFFF8E1 });
                const cover = new THREE.Mesh(
                    new THREE.BoxGeometry(0.7, 0.45, 0.15),
                    coverMat
                );
                const pages = new THREE.Mesh(
                    new THREE.BoxGeometry(0.64, 0.38, 0.12),
                    pageMat
                );
                cover.position.set(1.5, 0.8, 0);
                pages.position.copy(cover.position);
                pages.position.z += 0.02;
                group.add(cover, pages);
                return group;
            }
        }

        };

        // å­˜æ”¾å·²å‰µå»ºçš„ 3D ç‰©ä»¶å¯¦é«”çš„ç·©å­˜ { id: meshObject }
        const loadedAccessories = {};

        // ==========================================
        // 3. Three.js 3D å ´æ™¯åŸºç¤è¨­ç½®
        // ==========================================
        let scene, camera, renderer, vegeGroup, defaultBlush, defaultMouth;
        let currentEmotion = "neutral";
        let leftHand, rightHand;  // ğŸ‘ˆ æ–°å¢

        function init3D() {
            scene = new THREE.Scene();
            // èª¿æ•´ç›¸æ©Ÿè§’åº¦æ›´é©åˆæ‰‹æ©Ÿ
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / (window.innerHeight * 0.6), 0.1, 1000);
            camera.position.set(0, 0.5, 4.5);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight * 0.6);
            renderer.setPixelRatio(window.devicePixelRatio); // å„ªåŒ–æ‰‹æ©Ÿè§£æåº¦
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(3, 5, 5);
            scene.add(dirLight);
// --- è”¬èœå¯¶å¯¶æœ¬é«” (æ”¹è‰¯ç‰ˆ) ---
            vegeGroup = new THREE.Group();
            scene.add(vegeGroup);

            // 1. [èº«é«”]ï¼šæŠŠçƒé«”ç¨å¾®å£“æ‰ï¼Œåƒéº»ç³¬ä¸€æ¨£
            // ä½¿ç”¨ IcosahedronGeometry (äºŒåé¢é«”) å†åŠ ä¸Šç´°åˆ†ï¼Œæœƒæ¯” Sphere çœ‹èµ·ä¾†æ›´æŸ”å’Œä¸€é»ï¼Œæˆ–è€…ç¹¼çºŒç”¨ Sphere ä½†èª¿æ•´ç¸®æ”¾
            const bodyGeo = new THREE.SphereGeometry(1, 32, 32); 
            // æ›ä¸€å€‹ç¨å¾®ç²‰å«©ä¸€é»çš„ç¶ è‰²ï¼Œä¸è¦é‚£éº¼åˆºçœ¼
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0xAED581 }); 
            const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
            
            // â˜… é—œéµï¼šå£“æ‰å®ƒï¼(X:1, Y:0.85, Z:1) çœ‹èµ·ä¾†æœ‰é‡åŠ›æ„Ÿ
            bodyMesh.scale.set(1, 0.9, 1); 
            vegeGroup.add(bodyMesh);

            // 2. [æ‰‹æ‰‹]ï¼šçŸ­çŸ­åœ“åœ“çš„å°æ‰‹
            const limbGeo = new THREE.SphereGeometry(0.25, 16, 16);
const limbMat = new THREE.MeshLambertMaterial({ color: 0xAED581 }); // åŒèº«é«”è‰²

leftHand = new THREE.Mesh(limbGeo, limbMat);
leftHand.position.set(-0.9, -0.2, 0); // æ”¾åœ¨èº«é«”å…©å´åä¸‹
leftHand.scale.set(1, 0.8, 1);

rightHand = new THREE.Mesh(limbGeo, limbMat);
rightHand.position.set(0.9, -0.2, 0);
rightHand.scale.set(1, 0.8, 1);

vegeGroup.add(leftHand, rightHand);

// è¨˜ä¸‹ã€Œé è¨­æ‰‹çš„ä½ç½®ã€ï¼Œä¹‹å¾Œæƒ…ç·’çµæŸè¦å›ä¾†
leftHand.userData.defaultPos = leftHand.position.clone();
rightHand.userData.defaultPos = rightHand.position.clone();

            // 3. [è…³è…³]ï¼šåœ¨åº•éƒ¨çš„å°åœ“çƒ
            const leftFoot = new THREE.Mesh(limbGeo, limbMat);
            leftFoot.position.set(-0.4, -0.9, 0.2); // ç¨å¾®å¾€å‰ä¼¸ä¸€é»
            leftFoot.scale.set(1, 0.6, 1.2); // å£“æ‰æ‹‰é•·åƒè…³æŒ
            
            const rightFoot = new THREE.Mesh(limbGeo, limbMat);
            rightFoot.position.set(0.4, -0.9, 0.2);
            rightFoot.scale.set(1, 0.6, 1.2);

            vegeGroup.add(leftFoot, rightFoot);

            // 4. [å‘†æ¯›/è‘‰å­]ï¼šé ­é ‚æ°¸ä¹…åŠ ä¸Šä¸€å€‹å°è‘‰å­ï¼Œå¼·èª¿å®ƒæ˜¯è”¬èœ
            // é€™æ¨£å°±ç®—æ²’æˆ´å¸½å­ï¼Œä¹Ÿçœ‹å¾—å‡ºæ˜¯è”¬èœ
            const leafGroup = new THREE.Group();
            const leafGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x8BC34A });
            const l1 = new THREE.Mesh(leafGeo, leafMat); l1.position.set(-0.1, 0.1, 0); l1.scale.set(0.5, 1, 0.5); l1.rotation.z = 0.5;
            const l2 = new THREE.Mesh(leafGeo, leafMat); l2.position.set(0.1, 0.1, 0); l2.scale.set(0.5, 0.8, 0.5); l2.rotation.z = -0.5;
            leafGroup.add(l1, l2);
            leafGroup.position.set(0, 0.9, 0); // æ”¾åœ¨é ­é ‚
            vegeGroup.add(leafGroup);

            // 5. [çœ¼ç›]ï¼šæ›´æ›æè³ªï¼Œå¢åŠ ä¸€é»é»åå…‰(é«˜å…‰)ï¼Œä¸¦å¾€ä¸‹ç§»
            const eyeGeo = new THREE.SphereGeometry(0.1, 16, 16);
            const eyeMat = new THREE.MeshPhongMaterial({ 
                color: 0x212121, 
                shininess: 100 // è®“çœ¼ç›æœ‰é»æ°´æ±ªæ±ªçš„åå…‰
            });
            
            // â˜… é—œéµï¼šä½ç½®å¾€ä¸‹ç§» (Y: 0.2 -> 0.05)ï¼Œå¾€å¤–é–‹ä¸€é»ï¼Œè®“é¡é ­è®Šå¤§
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat); 
            leftEye.position.set(-0.4, 0.05, 0.85); 
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat); 
            rightEye.position.set(0.4, 0.05, 0.85);
            
            vegeGroup.add(leftEye); vegeGroup.add(rightEye);

            // 6. [å˜´å·´]ï¼šç”¨ä¸€å€‹æ¥µå°çš„åŠåœ“ç’°æˆ–æ˜¯å°çƒä»£è¡¨å˜´å·´
            const mouthGeo = new THREE.TorusGeometry(0.08, 0.02, 8, 16, Math.PI); // åŠåœ“
            const mouthMat = new THREE.MeshBasicMaterial({ color: 0x212121 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.rotation.x = Math.PI / 2; // è½‰æ­£
            mouth.position.set(0, -0.05, 0.88); // åœ¨çœ¼ç›ä¸­é–“åä¸‹
            vegeGroup.add(mouth);
            defaultMouth = mouth;   // â˜… æ–°å¢ï¼šä¹‹å¾Œæ›å˜´å‹æ™‚è¦éš±è—å®ƒ

            // 7. [é è¨­è…®ç´…]ï¼šèª¿æ•´ä½ç½®é…åˆæ–°è‡‰å‹
            defaultBlush = new THREE.Group();
            const blushGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const blushMat = new THREE.MeshBasicMaterial({ color: 0xFF8A80, transparent: true, opacity: 0.5 }); // æ›´ç²‰å«©çš„é¡è‰²
            
            const leftBlush = new THREE.Mesh(blushGeo, blushMat); 
            leftBlush.position.set(-0.65, -0.15, 0.75); // å¾€ä¸‹ç§»
            leftBlush.scale.set(1, 0.6, 0.5); // è²¼åœ¨è‡‰ä¸Š
            
            const rightBlush = new THREE.Mesh(blushGeo, blushMat); 
            rightBlush.position.set(0.65, -0.15, 0.75); 
            rightBlush.scale.set(1, 0.6, 0.5);
            
            defaultBlush.add(leftBlush, rightBlush);
            vegeGroup.add(defaultBlush);

            animate();
            // --- æ–°å¢ï¼šæµ®å‹• Emoji ç‰¹æ•ˆç³»çµ± ---
        function spawnFloatingEmoji(type) {
            const emojiMap = {
                'happy': ['âœ¨', 'ğŸ¶', 'ğŸ¥°', 'ğŸ˜†'],
                'sad': ['ğŸ’§', 'ğŸŒ§ï¸', 'ğŸ’”', 'ğŸ¥º'],
                'anxious': ['ğŸ’«', 'ğŸŒ€', 'ğŸ’¦', 'ğŸ˜–'],
                'love': ['â¤ï¸', 'ğŸ’–', 'ğŸŒ¹', 'ğŸ˜½'],
                'angry': ['ğŸ’¢', 'ğŸ˜¤', 'ğŸ”¥', 'ğŸ˜¡'],
                'neutral': ['ğŸŒ±', 'ğŸ‘€', 'ğŸ’­']
            };
            
            // éš¨æ©Ÿé¸ä¸€å€‹è©²æƒ…ç·’çš„ Emoji
            const list = emojiMap[type] || emojiMap['neutral'];
            const emojiChar = list[Math.floor(Math.random() * list.length)];

            // å»ºç«‹ HTML å…ƒç´ 
            const el = document.createElement('div');
            el.textContent = emojiChar;
            el.style.position = 'absolute';
            el.style.left = '50%';
            el.style.top = '40%'; // å¾è”¬èœå¯¶å¯¶é ­é ‚ä½ç½®é–‹å§‹
            el.style.transform = 'translate(-50%, -50%)';
            el.style.fontSize = '30px';
            el.style.pointerEvents = 'none';
            el.style.transition = 'all 1s ease-out';
            el.style.opacity = '1';
            el.style.zIndex = '50';
            
            document.getElementById('game-container').appendChild(el);

            // å‹•ç•«ï¼šå¾€ä¸Šé£„ä¸¦æ¶ˆå¤±
            // ä½¿ç”¨ requestAnimationFrame ç¢ºä¿å‹•ç•«æµæš¢
            let startTime = null;
            function floatUp(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = timestamp - startTime;
                
                // å¾€ä¸Šé£„ç§» 100px
                const moveY = - (progress / 10); 
                el.style.transform = `translate(-50%, calc(-50% + ${moveY}px)) scale(${1 + progress/1000})`;
                el.style.opacity = 1 - (progress / 1000); // 1ç§’å¾Œå®Œå…¨é€æ˜

                if (progress < 1000) {
                    requestAnimationFrame(floatUp);
                } else {
                    el.remove(); // å‹•ç•«çµæŸå¾Œåˆªé™¤å…ƒç´ 
                }
            }
            requestAnimationFrame(floatUp);
        }
        }
        // --- æ–°å¢ï¼šæµ®å‹• Emoji ç‰¹æ•ˆ (è®“å®ƒåƒè²¼åœ–ä¸€æ¨£å†’æ„›å¿ƒ) ---
        function spawnFloatingEmoji(type) {
            const emojiMap = {
                'happy': ['âœ¨', 'ğŸ¶', 'ğŸ¥°', 'ğŸ˜†', 'ğŸ…'],
                'sad': ['ğŸ’§', 'ğŸŒ§ï¸', 'ğŸ’”', 'ğŸ¥º', 'ğŸ„'],
                'anxious': ['ğŸ’«', 'ğŸŒ€', 'ğŸ’¦', 'ğŸ˜–', 'ğŸ¥”'],
                'love': ['â¤ï¸', 'ğŸ’–', 'ğŸŒ¹', 'ğŸ˜½', 'ğŸ¥¬'],
                'angry': ['ğŸ’¢', 'ğŸ˜¤', 'ğŸ”¥', 'ğŸ˜¡', 'ğŸŒ¶ï¸'],
                'neutral': ['ğŸŒ±', 'ğŸ‘€', 'ğŸ’­']
            };
            
            // éš¨æ©Ÿé¸ä¸€å€‹ç¬¦è™Ÿ
            const list = emojiMap[type] || emojiMap['neutral'];
            const emojiChar = list[Math.floor(Math.random() * list.length)];

            // å»ºç«‹å…ƒç´ 
            const el = document.createElement('div');
            el.textContent = emojiChar;
            el.style.position = 'absolute';
            el.style.left = '50%';
            el.style.top = '40%'; // å¾è”¬èœé ­é ‚å†’å‡ºä¾†
            el.style.transform = 'translate(-50%, -50%)';
            el.style.fontSize = '40px'; // ç¬¦è™Ÿå¤§ä¸€é»
            el.style.pointerEvents = 'none';
            el.style.transition = 'all 1.5s ease-out'; // æ…¢æ…¢é£„
            el.style.zIndex = '100';
            el.style.opacity = '1';
            el.style.textShadow = '0 2px 5px rgba(0,0,0,0.2)'; // åŠ é»é™°å½±æ¯”è¼ƒç«‹é«”
            
            document.getElementById('game-container').appendChild(el);

            // å‹•ç•«ï¼šå¾€ä¸Šé£„ä¸¦æ¶ˆå¤±
            requestAnimationFrame(() => {
                // ç‚ºäº†è®“ transition ç”Ÿæ•ˆï¼Œè¦ç¨å¾®å»¶é²ä¸€ä¸‹è¨­å®šæ–°ä½ç½®
                setTimeout(() => {
                    el.style.top = '20%'; // å¾€ä¸Šé£„åˆ° 20% çš„é«˜åº¦
                    el.style.opacity = '0'; // è®Šé€æ˜
                    el.style.transform = `translate(-50%, -50%) scale(1.5) rotate(${Math.random()*30-15}deg)`; // è®Šå¤§ä¸¦ç¨å¾®æ—‹è½‰
                }, 50);
            });

            // 1.5ç§’å¾Œåˆªé™¤åƒåœ¾
            setTimeout(() => { el.remove(); }, 1500);
        }

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;

    // åŸºç¤å‘¼å¸å¾‹å‹•
    let bounceBase = Math.sin(time * 2) * 0.05;

    // æƒ…ç·’å‹•ç•«é‚è¼¯ï¼ˆèº«é«”ï¼‰
    if (currentEmotion === "happy") {
        // é–‹å¿ƒï¼šå¤§å¹…åº¦è·³èº + å·¦å³æ–
        vegeGroup.position.y = Math.abs(Math.sin(time * 7)) * 0.5;
        vegeGroup.rotation.z = Math.sin(time * 5) * 0.18;
        vegeGroup.position.x = 0;

    } else if (currentEmotion === "sad") {
        // é›£éï¼šæ•´é«”å¾®å¾®ä¸‹æ²‰ + ä½é ­
        vegeGroup.position.y = Math.sin(time * 1.5) * 0.03 - 0.12;
        vegeGroup.rotation.x = 0.25;
        vegeGroup.rotation.z = 0;
        vegeGroup.position.x = 0;

    } else if (currentEmotion === "anxious") {
        // ç„¦æ…®ï¼šå·¦å³å¿«é€ŸæŠ–å‹• + å¾®å¾®ä¸Šä¸‹
        vegeGroup.position.x = Math.sin(time * 25) * 0.04;
        vegeGroup.position.y = bounceBase * 0.6;
        vegeGroup.rotation.z = Math.sin(time * 20) * 0.08;
        vegeGroup.rotation.x = 0;

    } else if (currentEmotion === "angry") {
        // ç”Ÿæ°£ï¼šåŸåœ°éœ‡å‹• + èº«é«”æœ‰é»å‰å‚¾
        vegeGroup.position.y = bounceBase * 0.3;
        vegeGroup.position.x = Math.sin(time * 18) * 0.03;
        vegeGroup.rotation.x = 0.18;
        vegeGroup.rotation.z = Math.sin(time * 12) * 0.1;

    } else if (currentEmotion === "love") {
        // æˆ€æ„›ï¼šè¼•è¼•å·¦å³æ– + å°å¹…åº¦æµ®èµ·ä¾†
        vegeGroup.position.y = 0.08 + Math.sin(time * 2.5) * 0.08;
        vegeGroup.position.x = Math.sin(time * 1.5) * 0.05;
        vegeGroup.rotation.z = Math.sin(time * 2) * 0.08;
        vegeGroup.rotation.x = 0;

    } else {
        // neutral / é è¨­ï¼šå¾®å¾®å‘¼å¸æ“ºå‹•
        vegeGroup.position.y = bounceBase;
        vegeGroup.position.x = 0;
        vegeGroup.rotation.z = 0;
        vegeGroup.rotation.x = 0;
    }

    renderer.render(scene, camera);
}


        window.addEventListener('resize', () => {
            // æ‰‹æ©Ÿæ—‹è½‰æˆ–è¦–çª—æ”¹è®Šæ™‚èª¿æ•´
            const width = window.innerWidth;
            const height = window.innerHeight * 0.6;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });


        // ==========================================
        // 4. æ›è£é‚è¼¯æ ¸å¿ƒ
        // ==========================================

    function toggleAccessory(itemId) {
    const def = accessoryDefinitions[itemId];
    if (!def) return;

    // 1. åŒä¸€éƒ¨ä½äº’æ–¥ï¼šå…ˆå¸ä¸‹åŒ type çš„å…¶ä»–è£å‚™
    for (let id in gameState.equipped) {
        if (!gameState.equipped[id]) continue;
        if (!accessoryDefinitions[id]) continue;

        const otherDef = accessoryDefinitions[id];
        if (otherDef.type !== def.type || id === itemId) continue;

        const parentOld = otherDef.type === 'background' ? scene : vegeGroup;

        if (loadedAccessories[id]) {
            parentOld.remove(loadedAccessories[id]);
        }
        gameState.equipped[id] = false;

        // UIï¼šå–æ¶ˆé¸å–ç‹€æ…‹
        const otherBtn = document.querySelector(`.item-btn[data-id="${id}"]`);
        if (otherBtn) otherBtn.classList.remove('active');

        // ç‰¹æ®Šï¼šè‡‰éƒ¨è…®ç´… / å˜´å·´
        if (otherDef.type === 'face' && id.includes('blush')) {
            defaultBlush.visible = true;
        }
        if (otherDef.type === 'mouth' && defaultMouth) {
            defaultMouth.visible = true;
        }
    }

    // 2. åˆ‡æ›é€™å€‹ item çš„ç‹€æ…‹
    gameState.equipped[itemId] = !gameState.equipped[itemId];

    const parent = def.type === 'background' ? scene : vegeGroup;

    // 3. åŠ ä¸Š / æ‹¿æ‰ 3D ç‰©ä»¶
    if (gameState.equipped[itemId]) {
        if (!loadedAccessories[itemId]) {
            loadedAccessories[itemId] = def.create();
        }
        parent.add(loadedAccessories[itemId]);

        // ç‰¹æ®Šè™•ç†ï¼šè…®ç´…
        if (def.type === 'face' && itemId.includes('blush')) {
            defaultBlush.visible = false;
        }
        // ç‰¹æ®Šè™•ç†ï¼šå˜´å·´ -> éš±è—é è¨­å˜´å·´
        if (def.type === 'mouth' && defaultMouth) {
            defaultMouth.visible = false;
        }

        // ç‰¹æ®Šè™•ç†ï¼šèƒŒæ™¯ -> æ”¹ canvas çš„èƒŒæ™¯æ¼¸å±¤
        if (def.type === 'background') {
            const canvas = document.getElementById('canvas-container');
            canvas.style.background = def.bg || CANVAS_DEFAULT_BG;
        }

    } else {
        // è„«ä¸‹
        if (loadedAccessories[itemId]) {
            parent.remove(loadedAccessories[itemId]);
        }

        if (def.type === 'face' && itemId.includes('blush')) {
            defaultBlush.visible = true;
        }
        if (def.type === 'mouth' && defaultMouth) {
            defaultMouth.visible = true;
        }

        if (def.type === 'background') {
            const canvas = document.getElementById('canvas-container');
            canvas.style.background = CANVAS_DEFAULT_BG;
        }
    }

    // 4. UI æŒ‰éˆ•æ¨£å¼
    const btn = document.querySelector(`.item-btn[data-id="${itemId}"]`);
    if (btn) btn.classList.toggle('active', gameState.equipped[itemId]);

    console.log('ç•¶å‰è£å‚™:', gameState.equipped);
}

        // å‹•æ…‹ç”Ÿæˆæ›è£é¢æ¿ UI
        function generateWardrobeUI() {
            const contentDiv = document.getElementById('wardrobe-content');
        const categories = {
    'head': 'é ­é£¾',
    'face': 'è‡‰éƒ¨',
    'mouth': 'å˜´å·´',
    'body': 'èº«é«”',
    'floating': 'æ¼‚æµ®',
    'background': 'èƒŒæ™¯'   // â˜… æ–°å¢èƒŒæ™¯åˆ†é¡
};
            for (let typeKey in categories) {
                // åŠ å…¥åˆ†é¡æ¨™é¡Œ
                const title = document.createElement('div');
                title.className = 'wardrobe-section-title';
                title.textContent = categories[typeKey];
                contentDiv.appendChild(title);

                // å»ºç«‹ç¶²æ ¼å®¹å™¨
                const grid = document.createElement('div');
                grid.className = 'item-grid';

                // æ‰¾å‡ºè©²åˆ†é¡çš„æ‰€æœ‰é…ä»¶
                for (let id in accessoryDefinitions) {
                    if (accessoryDefinitions[id].type === typeKey) {
                        const item = accessoryDefinitions[id];
                        const btn = document.createElement('button');
                        btn.className = 'item-btn';
                        btn.dataset.id = id; // å­˜ ID æ–¹ä¾¿æŸ¥æ‰¾
                        btn.innerHTML = `<span>${item.icon}</span>${item.name}`;
                        btn.onclick = () => toggleAccessory(id);
                        if (gameState.equipped[id]) btn.classList.add('active');
                        grid.appendChild(btn);
                    }
                }
                contentDiv.appendChild(grid);
            }
        }


        // ==========================================
        // 5. èŠå¤©èˆ‡ API æ¨¡æ“¬ (ç¶­æŒä¸è®Š)
        // ==========================================
        const mockResponses = {
            "happy": { text: "å“‡ï¼ä½ ä»Šå¤©çœ‹èµ·ä¾†å°±åƒå‰›æ‘˜ä¸‹ä¾†çš„ã€Œé®®æ¡ç•ªèŒ„ã€ä¸€æ¨£äº®æ™¶æ™¶çš„ï¼å¿ƒæƒ…çœŸå¥½ï¼ğŸ…âœ¨", emotion: "happy" },
            "sad": { text: "æ€éº¼äº†ï¼Ÿè‘‰å­éƒ½å‚ä¸‹ä¾†äº†... æ²’é—œä¿‚ï¼Œæˆ‘æ˜¯ä½ çš„ã€Œé˜²é¢¨æ—ã€ï¼Œåœ¨é€™è£¡é™ªä½ ã€‚ğŸŒ³", emotion: "sad" },
            "anxious": { text: "è…¦è¢‹æ˜¯ä¸æ˜¯åƒã€Œæ‰“çµçš„æµ·å¸¶ã€ä¸€æ¨£äº‚ç³Ÿç³Ÿçš„ï¼Ÿæ·±å‘¼å¸ï½æˆ‘å€‘æ…¢æ…¢æŠŠå®ƒè§£é–‹ã€‚ğŸŒŠ", emotion: "anxious" },
            "love": { text: "å“å”·ï½è½åˆ°äº†å…«å¦çš„å‘³é“ï¼æ„Ÿæƒ…å°±åƒç¨®ã€Œè‰è“ã€ï¼Œè¦ç´°å¿ƒå‘µè­·æ‰æœƒç”œå–”ã€‚ğŸ“", emotion: "happy" },
            "default": { text: "å—¯å—¯...ï¼ˆèªçœŸåš¼åš¼åš¼ï¼‰æˆ‘åœ¨è½å–”ï¼Œä½ ç¹¼çºŒèªªã€‚", emotion: "neutral" }
        };

        // æ›¿æ›åŸæœ¬çš„ simulateAPI å‡½å¼
        async function simulateAPI(userText) {
            // é¡¯ç¤ºæ€è€ƒæ¡†
            const bubble = document.getElementById('thinking-bubble');
            bubble.style.display = 'block';
            bubble.textContent = 'è”¬èœå¯¶å¯¶æ€è€ƒä¸­...';

            try {
                // 1. ç™¼é€è«‹æ±‚çµ¦ä½ çš„ Python å¾Œç«¯ (localhost:5000)
                const response = await fetch('http://127.0.0.1:5000/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message: userText })
                });

                // 2. æ¥æ”¶çµæœ
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                const data = await response.json();
                
                // éš±è—æ€è€ƒæ¡†
                bubble.style.display = 'none';

                // 3. å›å‚³å¾Œç«¯çµ¦çš„è³‡æ–™ { text: "...", emotion: "..." }
                // ç‚ºäº†é˜²æ­¢ API æ²’å›å‚³ emotionï¼Œçµ¦ä¸€å€‹é è¨­å€¼
                return { 
                    text: data.text, 
                    emotion: data.emotion || "neutral" 
                };

            } catch (error) {
                console.error('Error:', error);
                bubble.style.display = 'none';
                return { 
                    text: "æŠ±æ­‰ï¼Œæˆ‘å¥½åƒåƒå¤ªé£½è…¦è¢‹å¡ä½äº†... (ä¼ºæœå™¨æ²’é–‹?)", 
                    emotion: "anxious" 
                };
            }
        }
        async function sendMessage() {
            const input = document.getElementById('user-input');
            const text = input.value.trim();
            if (!text) return;
            input.value = ''; 
            addMsg(text, 'user');
            

            const res = await simulateAPI(text);
            addMsg(res.text, 'bot');
            setEmotion(res.emotion); 
            
            // â˜…â˜…â˜… æ–°å¢é€™å¹¾è¡Œï¼šè®“å®ƒé€£çºŒå†’å‡º 3 å€‹è¡¨æƒ…ï¼Œå¾ˆæœ‰è²¼åœ–æ„Ÿ â˜…â˜…â˜…
            spawnFloatingEmoji(res.emotion);
            setTimeout(() => spawnFloatingEmoji(res.emotion), 300);
            setTimeout(() => spawnFloatingEmoji(res.emotion), 600);

            
            
            // å¢åŠ å¥½æ„Ÿåº¦æ¢ (ç°¡å–®ç¤ºç¯„)
            gameState.affectionScore = Math.min(gameState.affectionScore + 5, 100);
            updateAffectionUI();
        }

   function setEmotion(emotion) {
    currentEmotion = emotion;
    applyPoseByEmotion(emotion);  // ä¾æƒ…ç·’èª¿æ•´æ‰‹çš„å§¿å‹¢

    // 4 ç§’å¾Œå›åˆ°ä¸­ç«‹ & æ‰‹ä¹Ÿæ­¸ä½
    setTimeout(() => {
        currentEmotion = "neutral";
        applyPoseByEmotion("neutral");
    }, 4000);
}
       function applyPoseByEmotion(emotion) {
    if (!leftHand || !rightHand) return;

    // ç¢ºä¿æœ‰è¨˜ä½é è¨­ä½ç½®
    if (!leftHand.userData.defaultPos) {
        leftHand.userData.defaultPos = leftHand.position.clone();
    }
    if (!rightHand.userData.defaultPos) {
        rightHand.userData.defaultPos = rightHand.position.clone();
    }

    const dl = leftHand.userData.defaultPos;
    const dr = rightHand.userData.defaultPos;

    // å„æƒ…ç·’çš„æ‰‹éƒ¨å§¿å‹¢
    if (emotion === "happy") {
        // é–‹å¿ƒï¼šé›™æ‰‹é«˜èˆ‰æ­¡å‘¼
        leftHand.position.set(dl.x - 0.1, dl.y + 0.5, 0.3);
        rightHand.position.set(dr.x + 0.1, dr.y + 0.5, 0.3);

    } else if (emotion === "sad") {
        // é›£éï¼šé›™æ‰‹æ‘€ä½è‡‰
        leftHand.position.set(-0.45, 0.25, 0.95);
        rightHand.position.set(0.45, 0.25, 0.95);

    } else if (emotion === "anxious") {
        // ç„¦æ…®ï¼šé›™æ‰‹æŠ±åœ¨èƒ¸å‰åƒæ˜¯åœ¨ç¸®èµ·ä¾†
        leftHand.position.set(-0.35, -0.05, 0.95);
        rightHand.position.set(0.35, -0.05, 0.95);

    } else if (emotion === "angry") {
        // ç”Ÿæ°£ï¼šé›™æ‰‹å‰è…°
        leftHand.position.set(-0.8, -0.15, 0.4);
        rightHand.position.set(0.8, -0.15, 0.4);

    } else if (emotion === "love") {
        // æˆ€æ„›ï¼šä¸€æ‰‹è²¼è‡‰ã€ä¸€æ‰‹æ”¾èƒ¸å‰
        leftHand.position.set(-0.45, 0.25, 0.95); // æ§è‡‰
        rightHand.position.set(0.1, -0.1, 0.9);   // æ”¾èƒ¸å‰

    } else {
        // neutral æˆ–æœªçŸ¥æƒ…ç·’ï¼šå›åˆ°é è¨­
        leftHand.position.copy(dl);
        rightHand.position.copy(dr);
    }
}



        function addMsg(text, sender) {
            const history = document.getElementById('chat-history');
            const div = document.createElement('div');
            div.className = `message ${sender}`;
            div.innerHTML = sender === 'bot' ? `<div class="bot-name">è”¬èœå¯¶å¯¶</div>${text}` : text;
            history.appendChild(div);
            history.scrollTop = history.scrollHeight;
        }

        function updateAffectionUI() {
            document.getElementById('affection-bar-fill').style.width = gameState.affectionScore + '%';
        }

        // ==========================================
        // 6. åˆå§‹åŒ–èˆ‡äº‹ä»¶ç¶å®š
        // ==========================================
        // UI äº‹ä»¶
        const wardrobePanel = document.getElementById('wardrobe-panel');
        document.getElementById('wardrobe-btn').onclick = () => wardrobePanel.style.display = 'block';
        document.getElementById('close-wardrobe').onclick = () => wardrobePanel.style.display = 'none';
        
        const sendBtn = document.getElementById('send-btn');
        const userInput = document.getElementById('user-input');
        sendBtn.onclick = sendMessage;
        userInput.onkeypress = (e) => { if(e.key==='Enter') sendMessage(); };
        
        // è§£æ±ºæ‰‹æ©Ÿéµç›¤å½ˆå‡ºæ™‚è¦–çª—é«˜åº¦å•é¡Œ
        userInput.addEventListener('focus', () => {
             setTimeout(() => {
                 document.getElementById('chat-history').scrollTop = document.getElementById('chat-history').scrollHeight;
             }, 300);
        });

        // å•Ÿå‹•
        init3D();
        updateAffectionUI();
        generateWardrobeUI(); // ç”Ÿæˆæ›è£é¢æ¿

    </script>
</body>
</html>
